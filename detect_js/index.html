<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Hello OpenCV.js</title>
    <style>
        .inputoutput img,
        .inputoutput canvas {
            max-width: 100%;
            /* Makes image and canvas not exceed the width of their container */
            max-height: 400px;
            /* Adjust this value based on your page layout */
            display: block;
            /* Ensures max-width and max-height are respected */
            margin: 0 auto;
            /* Centers the image/canvas if it's smaller than the max width */
        }
    </style>
    <script async src="opencv.js" type="text/javascript"></script>
</head>

<body>
    <h2>Hello OpenCV.js</h2>
    <p id="status">OpenCV.js is loading...</p>
    <button onclick="runDiceDetection()">Run Dice Detection</button>
    <div>
        <p id="timeTaken"></p>
        <div class="inputoutput">
            <img id="imageSrc" alt="No Image" src="../examples/far_full.jpg" />
            <div class="caption">imageSrc <input type="file" id="fileInput" name="file" /></div>
        </div>
        <div class="inputoutput">
            <img id="templateImage" alt="template" src="../resources/template.png"></canvas>
            <div class="caption">template</div>
        </div>
        <div class="inputoutput">
            <canvas id="templateRescaled"></canvas>
            <div class="caption">templateRescaled</div>
        </div>
        <div class="inputoutput">
            <canvas id="withTemplate"></canvas>
            <div class="caption">withTemplate</div>
        </div>
        <div class="inputoutput">
            <canvas id="gridOnly"></canvas>
            <div class="caption">gridOnly</div>
        </div>
        <div class="inputoutput">
            <canvas id="hsvOutput"></canvas>
            <div class="caption">hsvOutput</div>
        </div>
        <div class="inputoutput">
            <canvas id="hsvBlackOutput"></canvas>
            <div class="caption">hsvBlackOutput</div>
        </div>
        <div class="inputoutput">
            <canvas id="hsvBlackOutputContours"></canvas>
            <div class="caption">hsvBlackOutputContours</div>
        </div>
        <div class="inputoutput">
            <canvas id="hsvYellowOutput"></canvas>
            <div class="caption">hsvYellowOutput</div>
        </div>
        <div class="inputoutput">
            <canvas id="hsvYellowOutputContours"></canvas>
            <div class="caption">hsvYellowOutputContours</div>
        </div>
        <div class="inputoutput">
            <canvas id="hsvRedOutput"></canvas>
            <div class="caption">hsvRedOutput</div>
        </div>
        <div class="inputoutput">
            <canvas id="hsvRedOutputContours"></canvas>
            <div class="caption">hsvRedOutputContours</div>
        </div>
        <div class="inputoutput">
            <canvas id="hsvPurpleOutput"></canvas>
            <div class="caption">hsvPurpleOutput</div>
        </div>
        <div class="inputoutput">
            <canvas id="hsvPurpleOutputContours"></canvas>
            <div class="caption">hsvPurpleOutputContours</div>
        </div>
        <div class="inputoutput">
            <canvas id="hsvBlueOutput"></canvas>
            <div class="caption">hsvBlueOutput</div>
        </div>
        <div class="inputoutput">
            <canvas id="hsvBlueOutputContours"></canvas>
            <div class="caption">hsvBlueOutputContours</div>
        </div>
        <div class="inputoutput">
            <canvas id="hsvGreenOutput"></canvas>
            <div class="caption">hsvGreenOutput</div>
        </div>
        <div class="inputoutput">
            <canvas id="hsvGreenOutputContours"></canvas>
            <div class="caption">hsvGreenOutputContours</div>
        </div>
        <div class="inputoutput">
            <canvas id="hsvBlackOpened"></canvas>
            <div class="caption">hsvBlackOpened</div>
        </div>
        <div class="inputoutput">
            <canvas id="canvasOutput"></canvas>
            <div class="caption">canvasOutput</div>
        </div>
    </div>
    <script type="text/javascript">

        function getScale(src, dst, padding = 0.1) {
            let scaleHorizontal = (dst.cols * (1 - padding * 2)) / src.cols;
            let scaleVertical = (dst.rows * (1 - padding * 2)) / src.rows;
            let scale = Math.min(scaleHorizontal, scaleVertical);
            return scale;
        }

        function getTemplateGridRoi(template, scale = 1.0) {
            let left = 35;
            let top = 850;
            let right = 530;
            let bottom = 1245;
            let rowsFromPng = 1280;
            let colsFromPng = 565;
            let templateCols = template.cols;
            let templateRows = template.rows;
            let scaleCols = templateCols / colsFromPng * scale;
            let scaleRows = templateRows / rowsFromPng * scale;
            return new cv.Rect(left * scaleCols, top * scaleRows, (right - left) * scaleCols, (bottom - top) * scaleRows);
        }

        // Draw the template on the dst image
        // Returns the grid region of the dst image
        function drawTemplateOn(dst) {
            let template = cv.imread('templateImage');

            // rescale the template to match the dst height
            let padding = 0.1; // % of padding
            let scale = getScale(template, dst, padding);
            let templateRescaled = new cv.Mat();
            cv.resize(template, templateRescaled, new cv.Size(template.cols * scale, template.rows * scale), 0, 0, cv.INTER_AREA);

            let templateRoi = getTemplateGridRoi(template, scale);

            cv.imshow('templateRescaled', templateRescaled);

            // Draw the template in the middle of the dst
            let x = (dst.cols - templateRescaled.cols) / 2;
            let y = (dst.rows - templateRescaled.rows) / 2;

            templateRoi.x += x;
            templateRoi.y += y;

            let grid = dst.roi(templateRoi).clone();

            // Can't use cv.addWeighted because the template has an alpha channel
            for (let i = 0; i < templateRescaled.rows; i++) {
                for (let j = 0; j < templateRescaled.cols; j++) {
                    let pixel = templateRescaled.ucharPtr(i, j);
                    if (pixel[3] > 0) {
                        let dstPixel = dst.ucharPtr(y + i, x + j);
                        dstPixel[0] = pixel[0];
                        dstPixel[1] = pixel[1];
                        dstPixel[2] = pixel[2];
                    }
                }
            }

            template.delete(); templateRescaled.delete();

            return grid;
        }

        function getBlackMask(hsv) {
            // Threshold the HSV image to get only black colors 
            let hsvBlack = new cv.Mat();
            let low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [0, 0, 0, 0]);
            let high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [180, 255, 50, 0]);
            cv.inRange(hsv, low, high, hsvBlack);
            return hsvBlack;
        }

        function getYellowMask(hsv) {
            // Threshold the HSV image to get only yellow colors 
            let hsvYellow = new cv.Mat();
            let low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [180 * 0.085, 255 * 0.220, 255 * 0.204, 0]);
            let high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [180 * 0.247, 255, 255, 0]);
            cv.inRange(hsv, low, high, hsvYellow);
            return hsvYellow;
        }

        function getRedMask(hsv) {
            // Threshold the HSV image to get only red colors 
            let hsvRed = new cv.Mat();
            // Hue range for red is 0-15 and 165-180, since red is wrap around
            let low1 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [180 * 0.914, 255 * 0.220, 255 * 0.204, 0]);
            let high1 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [180, 255, 255, 0]);
            cv.inRange(hsv, low1, high1, hsvRed);

            let mat2 = new cv.Mat();
            let low2 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [0, 255 * 0.220, 255 * 0.204, 0]);
            let high2 = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [180 * 0.075, 255, 255, 0]);
            cv.inRange(hsv, low2, high2, mat2);

            cv.bitwise_or(hsvRed, mat2, hsvRed);
            mat2.delete();

            return hsvRed;
        }

        function getPurpleMask(hsv) {
            // Threshold the HSV image to get only purple colors 
            let hsvPurple = new cv.Mat();
            let low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [180 * 0.711, 255 * 0.171, 255 * 0.123, 0]);
            let high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [180 * 0.902, 255, 255, 0]);
            cv.inRange(hsv, low, high, hsvPurple);
            return hsvPurple;
        }

        function getBlueMask(hsv) {
            // Threshold the HSV image to get only blue colors 
            let hsvBlue = new cv.Mat();
            let low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [180 * 0.527, 255 * 0.327, 255 * 0.236, 0]);
            let high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [180 * 0.684, 255, 255, 0]);
            cv.inRange(hsv, low, high, hsvBlue);
            return hsvBlue;
        }

        function getGreenMask(hsv) {
            // Threshold the HSV image to get only green colors 
            let hsvGreen = new cv.Mat();
            let low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [180 * 0.354, 255 * 0.109, 255 * 0.07, 0]);
            let high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [180 * 0.497, 255, 255, 0]);
            cv.inRange(hsv, low, high, hsvGreen);
            return hsvGreen;
        }

        function getContours(hsv, imgSrcName) {
            // Function to get contours for given hsv and draw them
            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();

            cv.findContours(hsv, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);

            let dst = cv.Mat.zeros(hsv.rows, hsv.cols, cv.CV_8UC3);

            for (let i = 0; i < contours.size(); ++i) {
                let color = new cv.Scalar(255, 255, 255);
                cv.drawContours(dst, contours, i, color, 1, cv.LINE_8, hierarchy, 100);
            }

            cv.imshow(imgSrcName, dst);
            dst.delete();

            return contours;
        }

        function runDiceDetection() {
            var startTime = performance.now();

            let src = cv.imread('imageSrc');
            // Find edges using Hough Transform
            let dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);

            // Draw the template on the src copy
            let copy = src.clone();
            let grid = drawTemplateOn(copy);
            cv.imshow('withTemplate', copy);
            cv.imshow('gridOnly', grid);
            copy.delete();

            // Convert image to HSV
            let hsv = cv.Mat.zeros(grid.rows, grid.cols, cv.CV_8UC3);
            cv.cvtColor(grid, hsv, cv.COLOR_RGB2HSV, 0);
            cv.imshow('hsvOutput', hsv);

            // Threshold the HSV image to get only black colors 
            let hsvBlack = getBlackMask(hsv);
            cv.imshow('hsvBlackOutput', hsvBlack);
            let blackCountours = getContours(hsvBlack, hsvBlackOutputContours);

            // Threshold the HSV image to get only yellow colors
            let hsvYellow = getYellowMask(hsv);
            cv.imshow('hsvYellowOutput', hsvYellow);
            let yellowCountours = getContours(hsvYellow, hsvYellowOutputContours);

            // Threshold the HSV image to get only red colors
            let hsvRed = getRedMask(hsv);
            cv.imshow('hsvRedOutput', hsvRed);
            let redCountours = getContours(hsvRed, hsvRedOutputContours);

            // Threshold the HSV image to get only purple colors
            let hsvPurple = getPurpleMask(hsv);
            cv.imshow('hsvPurpleOutput', hsvPurple);
            let purpleCountours = getContours(hsvPurple, hsvPurpleOutputContours);

            // Threshold the HSV image to get only blue colors
            let hsvBlue = getBlueMask(hsv);
            cv.imshow('hsvBlueOutput', hsvBlue);
            let blueCountours = getContours(hsvBlue, hsvBlueOutputContours);

            // Threshold the HSV image to get only green colors
            let hsvGreen = getGreenMask(hsv);
            cv.imshow('hsvGreenOutput', hsvGreen);
            let greenCountours = getContours(hsvGreen, hsvGreenOutputContours);

            // Mask opening
            let kernel = cv.Mat.ones(3, 3, cv.CV_8U);
            let anchor = new cv.Point(-1, -1);
            let iterations = 1;
            let hsvBlackOpened = new cv.Mat();
            cv.morphologyEx(hsvBlack, hsvBlackOpened, cv.MORPH_OPEN, kernel, anchor, iterations);
            cv.imshow('hsvBlackOpened', hsvBlackOpened);

            let lines = new cv.Mat();
            let color = new cv.Scalar(255, 0, 0);
            // cv.cvtColor(hsv, src, cv.COLOR_RGBA2GRAY, 0);
            cv.Canny(hsvBlackOpened, hsvBlackOpened, 220, 250, 5);
            // You can try more different parameters
            cv.HoughLinesP(hsvBlackOpened, lines, 1, Math.PI / 180, 2, 0, 0);
            // draw lines
            for (let i = 0; i < lines.rows; ++i) {
                let startPoint = new cv.Point(lines.data32S[i * 4], lines.data32S[i * 4 + 1]);
                let endPoint = new cv.Point(lines.data32S[i * 4 + 2], lines.data32S[i * 4 + 3]);
                cv.line(dst, startPoint, endPoint, color);
            }
            cv.imshow('canvasOutput', dst);
            // Dispose the mats to free memory
            src.delete(); hsv.delete(); hsvBlackOpened.delete(); dst.delete(); lines.delete();
            hsvBlack.delete();
            hsvYellow.delete();
            hsvRed.delete();
            hsvPurple.delete();
            hsvBlue.delete();
            hsvGreen.delete();
            grid.delete();

            var endTime = performance.now();
            var timeTaken = endTime - startTime;
            document.getElementById('timeTaken').innerHTML = 'Time taken: ' + timeTaken + 'ms';
        }

        let imgElement = document.getElementById('imageSrc');
        let inputElement = document.getElementById('fileInput');
        inputElement.addEventListener('change', (e) => {
            imgElement.src = URL.createObjectURL(e.target.files[0]);
        }, false);

        var Module = {
            // https://emscripten.org/docs/api_reference/module.html#Module.onRuntimeInitialized
            onRuntimeInitialized() {
                document.getElementById('status').innerHTML = 'OpenCV.js is ready.';
                imgElement.onload = runDiceDetection;
            }
        };
    </script>


</body>

</html>